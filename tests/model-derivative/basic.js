/*
 * Basic comparison testing of outputs generated by Model Derivative service.
 *
 * Usage:
 *     # Generate new baseline for specific Forge object
 *     node tests/model-derivative/basic.js <forge bucket key> <forge  object key> --update
 *     # Test specific Forge object against an existing baseline
 *     node tests/model-derivative/basic.js <forge bucket key> <forge  object key>
 */

const path = require('path');
const fse = require('fs-extra');
const debug = require('debug');
const log = debug('test:log');
log.log = console.log.bind(console);
const error = debug('test:error');
const { DataManagementClient, ModelDerivativeClient, ManifestHelper, urnify } = require('forge-server-utils');
const { SvfReader } = require('forge-convert-utils');
const { downloadBaseline, uploadBaseline } = require('../../helpers/baseline');
const {
    compareFolders,
    compareObjects,
    compareTextures,
    compareProperties,
    compareFragments,
    compareMaterials,
    compareGeometryMetadata
} = require('../../helpers/compare');

const config = require('../../config');

const ImageDiffThreshold = 0.1;
const ForgeCredentials = { client_id: config.forge.client_id, client_secret: config.forge.client_secret };
const dataManagementClient = new DataManagementClient(ForgeCredentials);
const modelDerivativeClient = new ModelDerivativeClient(ForgeCredentials);

/**
 * Extracts new derivatives for a specific model and stores them in a local folder.
 * @async
 * @param {string} bucketKey Bucket key of the model in Forge Model Derivative service.
 * @param {string} objectKey Object key of the model in Forge Model Derivative service.
 * @param {string} outputDir Output directory for the extracted derivatives.
 */
async function extract(bucketKey, objectKey, outputDir) {
    let results = {
        urn: null,
        manifest: null,
        derivatives: []
    };

    fse.ensureDirSync(outputDir);
    // Getting object details
    log(`Retrieving object details`);
    const object = await dataManagementClient.getObjectDetails(bucketKey, objectKey);
    const urn = results.urn = urnify(object.objectId);
    const urnDir = path.join(outputDir, urn);
    fse.ensureDirSync(urnDir);
    // Download derivative manifest
    log(`Extracting manifest`);
    const manifest = results.manifest = await modelDerivativeClient.getManifest(urn);
    fse.writeJsonSync(path.join(urnDir, 'manifest.json'), manifest);
    // Download all SVFs
    const helper = new ManifestHelper(manifest);
    const graphicsDerivatives = helper.search({ type: 'resource', role: 'graphics' });
    for (const derivative of graphicsDerivatives.filter(derivative => derivative.mime === 'application/autodesk-svf')) {
        log(`Extracting viewable ${derivative.guid}`);
        const viewableDir = path.join(urnDir, derivative.guid);
        fse.ensureDirSync(viewableDir);
        const svf = await modelDerivativeClient.getDerivative(urn, derivative.urn);
        fse.writeFileSync(path.join(viewableDir, 'output.svf'), svf);
        const reader = await SvfReader.FromDerivativeService(urn, derivative.guid, ForgeCredentials);
        const manifest = await reader.getManifest();
        results.derivatives.push({
            guid: derivative.guid,
            basePath: path.join(urn, derivative.guid),
            svf: manifest
        });
        for (const asset of manifest.assets) {
            if (!asset.URI.startsWith('embed:')) {
                log(`Extracting asset ${asset.id}`);
                const assetData = await reader.getAsset(asset.URI);
                const assetPath = path.join(viewableDir, asset.URI);
                fse.ensureDirSync(path.dirname(assetPath));
                fse.writeFileSync(assetPath, assetData);
            } else {
                log(`Skipping embedded asset ${asset.id}`);
            }
        }
    }

    return results;
}

/**
 * Compares two local folders containing current and baseline derivatives extracted from a specific model.
 * @async
 * @param {string} baselineDir Directory where the baseline derivative content is located.
 * @param {string} currentDir Directory where the current derivative content is located.
 * @param {string} bucketKey Bucket key of the tested model in Forge Model Derivative service.
 * @param {string} objectKey Object key of the tested model in Forge Model Derivative service.
 * @param {object} extractResults Additional data generated when extracting new derivatives.
 */
async function compare(baselineDir, currentDir, bucketKey, objectKey, extractResults) {
    log('Comparing extracted folders and files');
    compareFolders(baselineDir, currentDir);

    log('Comparing model derivative manifests');
    const object = await dataManagementClient.getObjectDetails(bucketKey, objectKey);
    const urn = urnify(object.objectId);
    const baselineManifest = fse.readJsonSync(path.join(baselineDir, urn, 'manifest.json'));
    const currentManifest = fse.readJsonSync(path.join(currentDir, urn, 'manifest.json'));
    compareObjects(baselineManifest, currentManifest);

    if (extractResults.derivatives.length > 0) {
        // All derivatives share a single property db, so only test it once
        const firstDerivative = extractResults.derivatives[0];
        const pdbAsset = firstDerivative.svf.assets.find(asset => asset.type === 'Autodesk.CloudPlatform.PropertyAttributes');
        if (pdbAsset) {
            log('Comparing property database assets');
            const baselinePropsDir = path.join(baselineDir, firstDerivative.basePath, path.dirname(pdbAsset.URI));
            const currentPropsDir = path.join(currentDir, firstDerivative.basePath, path.dirname(pdbAsset.URI));
            compareProperties(baselinePropsDir, currentPropsDir);
        } else {
            throw new Error('Property database not found.');
        }

        // Compare individual derivatives
        for (const derivative of extractResults.derivatives) {
            log(`Comparing derivative ${derivative.guid}`);
            const baselineSvfPath = path.join(baselineDir, derivative.basePath);
            const currentSvfPath = path.join(currentDir, derivative.basePath);
            const baselineSvfReader = await SvfReader.FromFileSystem(path.join(baselineSvfPath, 'output.svf'));
            const currentSvfReader = await SvfReader.FromFileSystem(path.join(currentSvfPath, 'output.svf'));
            log('Comparing SVF fragments');
            await compareFragments(baselineSvfReader, currentSvfReader);
            log('Comparing SVF materials');
            await compareMaterials(baselineSvfReader, currentSvfReader);
            log('Comparing SVF geometry metadata');
            await compareGeometryMetadata(baselineSvfReader, currentSvfReader);
            log('Comparing SVF textures');
            await compareTextures(baselineSvfReader, baselineSvfPath, currentSvfReader, currentSvfPath, ImageDiffThreshold);
        }
    }
}

/**
 * Compares derivative content of a specific model with a previously stored baseline.
 * @async
 * @param {string} bucketKey Bucket key of the tested model in Forge Model Derivative service.
 * @param {string} objectKey Object key of the tested model in Forge Model Derivative service.
 */
async function test(bucketKey, objectKey) {
    log('Testing %s/%s', bucketKey, objectKey);
    try {
        const testName = 'model-derivative/basic/' + bucketKey + '/' + objectKey;
        const currentDir = path.join(process.cwd(), testName, 'current');
        const baselineDir = path.join(process.cwd(), testName, 'baseline');
        log('Extracting derivatives');
        const extractResults = await extract(bucketKey, objectKey, currentDir);
        log('Downloading baseline');
        await downloadBaseline(testName, baselineDir);
        log('Comparing derivatives against baseline');
        await compare(baselineDir, currentDir, bucketKey, objectKey, extractResults);
        log('Done!');
    } catch (err) {
        error('Test failed:');
        if (err.isAxiosError) {
            if (err.response) {
                const { data, status, headers } = err.response;
                error('Response status: %d', status);
                error('Response headers:\n%O', headers);
                error('Response data:\n%O', data);
            } else {
                error('%O', err);
            }
        } else {
            error('%O', err);
        }
        process.exit(1);
    }
}

/**
 * Uploads derivative content of a specific model as a new baseline.
 * @async
 * @param {string} bucketKey Bucket key of the tested model in Forge Model Derivative service.
 * @param {string} objectKey Object key of the tested model in Forge Model Derivative service.
 */
async function update(bucketKey, objectKey) {
    log('Updating baseline for %s/%s', bucketKey, objectKey);
    try {
        const testName = 'model-derivative/basic/' + bucketKey + '/' + objectKey;
        const currentDir = path.join(process.cwd(), testName, 'current');
        log('Extracting derivatives');
        await extract(bucketKey, objectKey, currentDir);
        log('Uploading baseline');
        await uploadBaseline(testName, currentDir);
        log('Done!');
    } catch (err) {
        error('Baseline update failed:');
        if (err.isAxiosError) {
            if (err.response) {
                const { data, status, headers } = err.response;
                error('Response status: %d', status);
                error('Response headers:\n%O', headers);
                error('Response data:\n%O', data);
            } else {
                error('Request:\n%O', err.request);
            }
        } else {
            error('%O', err);
        }
        process.exit(1);
    }
}

if (process.argv.indexOf('--update') !== -1) {
    update(process.argv[2], process.argv[3]);
} else {
    test(process.argv[2], process.argv[3]);
}
